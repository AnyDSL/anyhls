type pixel_t = i32;
type channel = channel_i32;
static use_hls = false;

fn @print_pixel(val: pixel_t) -> () { print_i32(val) };

struct Fifo1D {
    read    : fn(i32) -> pixel_t,
    shift   : fn(i32) -> (),
    width   : i32,
    vect_factor : i32
}

struct Fifo2D {
    read   : fn(i32, i32) -> pixel_t,
    shift  : fn(i32, i32) -> (),
    width  : i32,
    height : i32,
    vect_factor : i32
}

fn @new_Fifo1D(width: i32, vect_factor: i32, shift: fn(i32) -> (), read: fn(i32) -> pixel_t) -> Fifo1D {
    Fifo1D { width: width, vect_factor: vect_factor, shift: shift, read: read }
}


fn @make_linebuf1D_vec4(read_new: Read, width: int) -> Fifo1D {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let lbuf = reserve_shared[[pixel_t * 4]](width);

    fn @read(idx: int) -> pixel_t { value(idx) }

    fn @shift(col: int) -> () {
        // TODO: assert( col > width)
        value     = lbuf(col);
        let dlbin = [read_new(0), read_new(1), read_new(2), read_new(3)];
        lbuf(col) = dlbin;
    }

    new_Fifo1D(width, 4, shift, read)
}

type LineBuf1D = fn (Read) -> Fifo2D;

// Holds (height - 1) image lines
fn @make_linebuf2D(width: i32, height: i32, vect_factor: i32) -> LineBuf1D {
    |read_new| {
      if height == 1 {
          Fifo2D {
              read   : @|x, y| if y == 0 { read_new(x) }
                               else      { undef[pixel_t]() },
              shift  : @|_, _| (),
              height : height,
              width  : width,
              vect_factor: vect_factor
          }
      } else {
          let lbuf1d = make_linebuf1D_vec4(read_new, width);
          let lbuf2d = (make_linebuf2D(width, height - 1, vect_factor))(lbuf1d.read);
          Fifo2D {
              read : @|x, y| if y == height - 1 { read_new(x) }
                             else               { lbuf2d.read(x, y) },
              shift : @|col, row| { lbuf1d.shift($col);
                                    lbuf2d.shift($col, $row) },
              height : height,
              width  : width,
              vect_factor: vect_factor
          }
      }
    }
}


fn make_local_with_mem_lbuf(vect_factor: int, stencil: Stencil) -> fn(Img, Img) -> () {
    @ |arr_im, out_im| {
        let arr = make_img_mem1d(arr_im, vect_factor);
        let out = make_img_mem1d(out_im, vect_factor);

        let mask_height = stencil.extents.y * 2 + 1;

        let lbuf = (make_linebuf2D(arr.stride, mask_height, vect_factor))(arr.read);
        let delay = arr.stride * stencil.extents.y; // initial delay from line buffer

        let mut col = 0;
        for idx in pipeline(1, 0, arr.height * arr.stride + delay) {
            if (idx < arr.height * arr.stride) {
                arr.get(idx);   // read addr from image
            }
            lbuf.shift(col, 0); // read addr from lbuf1Ds (col < lbuf.width, row = 0)

            for i in unroll(0, vect_factor) {
                out.write(i, stencil.op(lbuf.read, stencil.extents.x + i, stencil.extents.y));
            }

            col++;
            if col == arr.stride { col = 0; }

            if (idx > delay - 1) { out.set(idx - delay); }
        }
    }
}


fn main() -> i32 {
    let width  = 1024;
    let height = 1024;

    let fpga = get_fpga_backend(use_hls);

    let vect_factor = 4;
    let arr = create_host_img(width, height, vect_factor);
    let out = create_host_img(width, height, vect_factor);
    for i in range(0, size_img(arr)) {
        img_write(arr, i, i as pixel_t);
        img_write(out, i, 0 as pixel_t);
    }

    let filter = stencil(@|read, x, y| {1 * read(x, y - 2) +
                                        3 * read(x, y - 1) +
                                        5 * read(x, y    ) +
                                        7 * read(x, y + 1) +
                                        9 * read(x, y + 2) / 1}, extents(0, 2));

    let operator = make_local_with_mem_lbuf(vect_factor, filter);
    host2host(fpga, arr, out, operator);

    let roi_disp = (0, 0); // (width - 10, height - 10)
    let offset = (filter.extents.x, filter.extents.y);
    let passed = check_with_ref(arr, out, |x, y| {filter.op(get_img_read2d(arr), x, y)}, roi_disp, offset);

    release_img(arr);
    release_img(out);

    if passed >= 256 { 255 } else { passed }
}
