struct Mem1D {
    read    : fn(i32) -> pixel_t,
    write   : fn(i32, pixel_t) -> (),
    get     : fn(i32) -> (), // update for read
    set     : fn(i32) -> (), // update for write
    height  : i32,
    width   : i32,
    stride  : i32,
    vect_factor : i32
}

fn @make_img_mem1d(img: Img, vect_factor: i32) -> Mem1D {
    match vect_factor {
         1 => make_img_mem_vec1 (img),
         2 => make_img_mem_vec2 (img),
         4 => make_img_mem_vec4 (img),
         8 => make_img_mem_vec8 (img),
        16 => make_img_mem_vec16(img),
        32 => make_img_mem_vec32(img),
         _ => undef[Mem1D]()
    }
}

fn @img_to_mem1d(img: Img, vect_factor: i32, get: fn(i32) -> (), set: fn(i32) -> (), read: fn(i32) -> pixel_t, write: fn(i32, pixel_t) -> ()) -> Mem1D {
    Mem1D{ read: read, write: write, get: get, set: set, height: img.height, width: img.width, stride: img.stride, vect_factor: vect_factor}
}

fn @make_img_mem_vec1(img: Img) -> Mem1D {
    let mut value = 0 as pixel_t;
    let global_read_fn = get_global_read_vec1(img);
    let global_write_fn = get_global_write_vec1(img);
    fn @get(idx: i32) -> () { value = global_read_fn(idx); }
    fn @set(idx: i32) -> () { global_write_fn(idx, value); }
    fn @read(idx: i32) -> pixel_t { value }
    fn @write(idx: i32, din: pixel_t) -> () { value = din; }
    img_to_mem1d(img, 1, get, set, read, write)
}

fn @make_img_mem_vec2(img: Img) -> Mem1D {
    let mut value = [ 0 as pixel_t, .. 2 ];
    let global_read_fn = get_global_read_vec2(img);
    let global_write_fn = get_global_write_vec2(img);
    fn @get(idx: i32) -> () { value = global_read_fn(idx); }
    fn @set(idx: i32) -> () { global_write_fn(idx, value); }
    fn @read(idx: i32) -> pixel_t { value(idx) }
    fn @write(idx: i32, din: pixel_t) -> () { value(idx) = din; }
    img_to_mem1d(img, 2, get, set, read, write)
}

fn @make_img_mem_vec4(img: Img) -> Mem1D {
    let mut value = [ 0 as pixel_t, .. 4 ];
    let global_read_fn = get_global_read_vec4(img);
    let global_write_fn = get_global_write_vec4(img);
    fn @get(idx: i32) -> () { value = global_read_fn(idx); }
    fn @set(idx: i32) -> () { global_write_fn(idx, value); }
    fn @read(idx: i32) -> pixel_t { value(idx) }
    fn @write(idx: i32, din: pixel_t) -> () { value(idx) = din; }
    img_to_mem1d(img, 4, get, set, read, write)
}

fn @make_img_mem_vec8(img: Img) -> Mem1D {
    let mut value = [ 0 as pixel_t, .. 8 ];
    let global_read_fn = get_global_read_vec8(img);
    let global_write_fn = get_global_write_vec8(img);
    fn @get(idx: i32) -> () { value = global_read_fn(idx); }
    fn @set(idx: i32) -> () { global_write_fn(idx, value); }
    fn @read(idx: i32) -> pixel_t { value(idx) }
    fn @write(idx: i32, din: pixel_t) -> () { value(idx) = din; }
    img_to_mem1d(img, 8, get, set, read, write)
}

fn @make_img_mem_vec16(img: Img) -> Mem1D {
    let mut value = [ 0 as pixel_t, .. 16 ];
    let global_read_fn = get_global_read_vec16(img);
    let global_write_fn = get_global_write_vec16(img);
    fn @get(idx: i32) -> () { value = global_read_fn(idx); }
    fn @set(idx: i32) -> () { global_write_fn(idx, value); }
    fn @read(idx: i32) -> pixel_t { value(idx) }
    fn @write(idx: i32, din: pixel_t) -> () { value(idx) = din; }
    img_to_mem1d(img, 16, get, set, read, write)
}

fn @make_img_mem_vec32(img: Img) -> Mem1D {
    let mut value = [ 0 as pixel_t, .. 32 ];
    let global_read_fn = get_global_read_vec32(img);
    let global_write_fn = get_global_write_vec32(img);
    fn @get(idx: i32) -> () { value = global_read_fn(idx); }
    fn @set(idx: i32) -> () { global_write_fn(idx, value); }
    fn @read(idx: i32) -> pixel_t { value(idx) }
    fn @write(idx: i32, din: pixel_t) -> () { value(idx) = din; }
    img_to_mem1d(img, 32, get, set, read, write)
}


fn @get_global_read_vec1(img: Img) -> fn(i32) -> pixel_t {
    let ptr = bitcast[&[1][pixel_t]](img.buf.data);
    |idx| { ptr($idx) }
}

fn @get_global_read_vec2(img: Img) -> fn(i32) -> [pixel_t * 2] {
    let ptr = if use_hls { bitcast[&[1][[pixel_t * 2]]](bitcast[&[1][pixel_t]](bitcast[&[1][[pixel_t * 2]]](img.buf.data))) }
                    else { bitcast[&[1][[pixel_t *  2]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx| { ptr($idx) }
}

fn @get_global_read_vec4(img: Img) -> fn(i32) -> [pixel_t * 4] {
    let ptr = if use_hls { bitcast[&[1][[pixel_t * 4]]](bitcast[&[1][pixel_t]](bitcast[&[1][[pixel_t * 4]]](img.buf.data))) }
                    else { bitcast[&[1][[pixel_t *  4]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx| { ptr($idx) }
}

fn @get_global_read_vec8(img: Img) -> fn(i32) -> [pixel_t * 8] {
    let ptr = if use_hls { bitcast[&[1][[pixel_t * 8]]](bitcast[&[1][pixel_t]](bitcast[&[1][[pixel_t * 8]]](img.buf.data))) }
                    else { bitcast[&[1][[pixel_t *  8]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx| { ptr($idx) }
}

fn @get_global_read_vec16(img: Img) -> fn(i32) -> [pixel_t * 16] {
    let ptr = if use_hls { bitcast[&[1][[pixel_t * 16]]](bitcast[&[1][pixel_t]](bitcast[&[1][[pixel_t * 16]]](img.buf.data))) }
                    else { bitcast[&[1][[pixel_t *  16]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx| { ptr($idx) }
}

fn @get_global_read_vec32(img: Img) -> fn(i32) -> [pixel_t * 32] {
    let ptr = if use_hls { bitcast[&[1][[pixel_t * 32]]](bitcast[&[1][pixel_t]](bitcast[&[1][[pixel_t * 32]]](img.buf.data))) }
                    else { bitcast[&[1][[pixel_t *  32]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx| { ptr($idx) }
}

fn @get_global_write_vec1(img: Img) -> fn(i32, pixel_t) -> () {
    let ptr = bitcast[&mut[1][pixel_t]](img.buf.data);
    |idx, value| { ptr($idx) = value }
}

fn @get_global_write_vec2(img: Img) -> fn(i32, [pixel_t * 2]) -> () {
    let ptr = if use_hls { bitcast[&mut[1][[pixel_t * 2]]](bitcast[&mut[1][pixel_t]](bitcast[&mut[1][[pixel_t * 2]]](img.buf.data))) }
                    else { bitcast[&mut[1][[pixel_t *  2]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx, value| { ptr($idx) = value; }
}

fn @get_global_write_vec4(img: Img) -> fn(i32, [pixel_t * 4]) -> () {
    let ptr = if use_hls { bitcast[&mut[1][[pixel_t * 4]]](bitcast[&mut[1][pixel_t]](bitcast[&mut[1][[pixel_t * 4]]](img.buf.data))) }
                    else { bitcast[&mut[1][[pixel_t *  4]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx, value| { ptr($idx) = value; }
}

fn @get_global_write_vec8(img: Img) -> fn(i32, [pixel_t * 8]) -> () {
    let ptr = if use_hls { bitcast[&mut[1][[pixel_t * 8]]](bitcast[&mut[1][pixel_t]](bitcast[&mut[1][[pixel_t * 8]]](img.buf.data))) }
                    else { bitcast[&mut[1][[pixel_t *  8]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx, value| { ptr($idx) = value; }
}

fn @get_global_write_vec16(img: Img) -> fn(i32, [pixel_t * 16]) -> () {
    let ptr = if use_hls { bitcast[&mut[1][[pixel_t * 16]]](bitcast[&mut[1][pixel_t]](bitcast[&mut[1][[pixel_t * 16]]](img.buf.data))) }
                    else { bitcast[&mut[1][[pixel_t *  16]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx, value| { ptr($idx) = value; }
}

fn @get_global_write_vec32(img: Img) -> fn(i32, [pixel_t * 32]) -> () {
    let ptr = if use_hls { bitcast[&mut[1][[pixel_t * 32]]](bitcast[&mut[1][pixel_t]](bitcast[&mut[1][[pixel_t * 32]]](img.buf.data))) }
                    else { bitcast[&mut[1][[pixel_t *  32]]](bitcast[&[1][pixel_t]](img.buf.data)) };
    |idx, value| { ptr($idx) = value; }
}
