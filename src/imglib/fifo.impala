struct Fifo1D {
    read    : fn(i32) -> pixel_t,
    shift   : fn(i32) -> (),
    width   : i32,
    vect_factor : i32
}

struct Fifo2D {
    read   : fn(i32, i32) -> pixel_t,
    shift  : fn(i32, i32) -> (),
    width  : i32,
    height : i32,
    vect_factor : i32
}

// API
fn @new_Fifo1D(width: i32, vect_factor: i32, shift: fn(i32) -> (), read: fn(i32) -> pixel_t) -> Fifo1D {
    Fifo1D { width: width, vect_factor: vect_factor, shift: shift, read: read }
}

fn @new_fifo2d(width: i32, height: i32, vect_factor: i32, shift: fn(i32, i32) -> (), read: fn(i32, i32) -> pixel_t) -> Fifo2D {
    Fifo2D { width: width, height: height, vect_factor: vect_factor, shift: shift, read: read }
}

// utilizes a register array to read from image
fn make_img_fifo2d(img: Img, height: i32, vect_factor: i32) -> Fifo2D {
      if height == 0 {
          Fifo2D {
              read   : @|x, y| undef[pixel_t](),
              shift  : @|_, _| (),
              height : height,
              width  : 1,
              vect_factor: vect_factor
          }
      } else {
          let arr = make_img_mem1d(img, vect_factor);
          let others = make_img_fifo2d(img, height - 1, vect_factor);
          Fifo2D {
              read : @|x, y| if y == height - 1 { arr.read(x) }
                             else               { others.read(x, y) },
              shift : @|col, row| { arr.get((col + row * arr.stride) + (height - 1) * arr.stride);
                                    others.shift(col, row); },
              height : height,
              width  : 1,
              vect_factor: vect_factor
          }
      }
}

