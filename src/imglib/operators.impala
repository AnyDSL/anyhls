type Operator = fn(Img, Img) -> ();

struct OperatorSchedule {
    read  : fn(i32, i32) -> pixel_t,
    write : fn(i32, i32, pixel_t) -> (),
    at    : fn(i32, BinOp) -> (),
    delay : i32
}

fn @make_read_2d(width: i32, read: Read) -> Read2d {
    |x, y| { read(y * width + x) }
}

fn make_point_op(vect_factor: int, op: StencilOp) -> Operator {
    @ |arr_im, out_im| {
        let arr = make_img_mem1d(arr_im, vect_factor);
        let out = make_img_mem1d(out_im, vect_factor);
        for idx in pipeline(1, 0, arr.height * arr.stride) {
            arr.get(idx);
            for i in unroll(0, arr.vect_factor) {
              out.write(i, op(make_read_2d(0, arr.read), i, 0));
            }
            out.set(idx);
        }
    }
}

fn make_local_op(vect_factor: int, stencil: Stencil) -> Operator {
    @ |arr_im, out_im| {
        let arr = make_img_mem1d(arr_im, vect_factor);
        let out = make_img_mem1d(out_im, vect_factor);

        let comp = make_fac_schedule(arr, out, stencil.extents, vect_factor);
        let loop = make_loop_pipeline(pipeline_range(1), comp.delay, arr.get, out.set);

        for idx in loop(0, arr.height * arr.stride) {
            for i, j in comp.at(idx) {
                comp.write(i, j, stencil.op(comp.read, i, j))
            }
        }
    }
}

fn @make_fac_schedule(arr: Mem1D, out: Mem1D, extents: Extents, vect_factor: i32) -> OperatorSchedule {
    let lbuf_width = arr.stride;
    let win_height = extents.y * 2 + 1;

    let delay_lbuf = lbuf_width * extents.y; // initial delay from line buffer
    let delay_swin = round_up(extents.x, vect_factor) / vect_factor; // initial delay from sliding window
    let swin_width = extents.x + (1 + delay_swin) * vect_factor;

    let lbuf = (make_linebuf2d(lbuf_width, win_height, vect_factor))(arr.read);
    let swin = (make_sliding_window(swin_width, win_height, vect_factor))(lbuf.read);

    let mut col = 0;
    let shift = || {
          lbuf.shift(col, 0); // read addr from lbuf1Ds (col < lbuf.lbuf_width, row = 0)
          swin.shift(0, 0);   // read addr from lbuf2D
          col++;
          if col == lbuf_width { col = 0; }
    };

    OperatorSchedule {
        delay: delay_lbuf + delay_swin,
        read:  @|i:i32, j:i32| { swin.read(extents.x + i, extents.y + j) },
        write: @|i:i32, j:i32, val:pixel_t| { out.write(i, val) },
        at: @|idx: i32, body: BinOp| {
            shift();
            for i, j in par(vect_factor, 1) { body(i, j) };
        }
    }
}
